### 类

##### 类大小

``` cpp
class A{};				    // sizeof(A) = 1
class A { virtual func() }; // sizeof(A) = 4 (32b) || 8 (64b)
class A {static int a; };   // sizeof(A) = 1
class A {int a;}            // sizeof(A) = 4
class A {static int a; int b;} // sizeof(A) = 4
```

#### 构造函数

##### 调用顺序：

- 基类；

- 成员类对象；

  ```cpp
  class B {
  public:
  	B() {}
  private:
  	A a;
  };
  // 先调用A类对象a的构造函数,构造a; 然后调用B类对象自身的构造函数B()
  ```

- 派⽣类构造函数;

> 析构函数正好相反：
>
> 1. 派生类；
> 2. 成员类对象；
> 3. 基类析构函数；



##### 抛出异常

!!! 禁止在构造函数中抛出异!!!

- C++ 只会析构已经完成的对象，对象只有在其构造函数执⾏完毕才算是完全构造妥当;

- 在构造函数中发⽣异常，控制权转出构造函数之外;
- 在对象 b 的构造函数中发⽣异常，对象b的析构函数不会被调⽤，因此会造成内存泄漏；

##### 成员初始化列表

- 在对象内存布局准备完成前直接给成员变量赋值
- 可以为引用和const类型成员变量赋初值
- 初始化顺序与成员变量声明顺序一致
- 比在构造函数体内赋值效率更高

类对象在构造函数执行前,分配好所有成员变量的内存空间；然后按列表顺序,直接把值拷贝到各个成员变量对应的内存空间；**这不需要先把整个对象构造好,再进行内部赋值操作**。



#### 虚函数

基类的函数前加上 virtual 关键字，在派⽣类中᯿写该函数，运⾏时将会根据对象的实际类型来调⽤相应的函数。如果对象类型是派⽣类，就调⽤派⽣类的函数，如果是基类，就调⽤基类的函数。

##### 构造过程

⼀个类中包含虚函数时，编译器会为该类⽣成⼀个虚函数表，保存该类中虚函数的地址，同样，派⽣类继承基类，派⽣类中⾃然⼀定有虚函数，所以编译器也会为派⽣类⽣成⾃⼰的虚函数表。当我们定义⼀个派⽣类对象时，编译器检测该类型有虚函数，所以为这个派⽣类对象⽣成⼀个虚函数指针，指向该类型的虚函数表，这个虚函数指针的初始化是在构造函数中完成的。

##### 析构函数一般写成虚函数

为了降低内存泄漏的可能性。举例来说就是，⼀个基类的指针指向⼀个派⽣类的对象，在使⽤完毕准备销毁时，如果基类的析构函数没有定义成虚函数，那 么编译器根据指针类型就会认为当前对象的类型是基类，调⽤基类的析构函数 （该对象的析构函数的函数地址早就被绑定为基类的析构函数），仅执⾏基类的析构，派⽣类的⾃身内容将⽆法被析构，造成内存泄漏。



##### 构造与析构函数调用虚函数

当我们创建⼀个派⽣类对象时，⾸先会创建派⽣类的基类部分，执⾏基类的构造函数，此时，派⽣类的⾃身部分还没有被初

始化，对于这种还没有初始化的东⻄，C++选择当它们还不存在作为⼀种安全的⽅法；

编译器会认为这就是⼀个基类类型的对象，然后调⽤基类类型中的虚函数实现；



#### 静态分配和动态分配

##### 静态分配

- 把 new、delete 运算符᯿载为 private 属性；
- A a； 在栈空间分配内存；



##### 动态分配

- 把构造、析构函数设为 protected 属性，再⽤⼦类来动态创建；
- A *p  = new A(); 动态创建对象：
  - 第⼀步执⾏ operator new() 函数，在堆中搜索⼀块内存并进⾏分配；
  - 调⽤类构造函数构造对象



#### 设计模式

##### 单例模式-懒汉式

```cpp
// SingleInstance.cpp

class SingleInstance {
public:
	static pthread_mutex_t mutex;
	static SingleInstance* getInstance() {
		if (ins == nullptr) {
			pthread_mutex_lock(&mutex);
			if (ins == nullptr) {
				ins = new SingleInstance();
			}
			pthread_mutex_unlock(&mutex);
		}
	}
private:
	static SingleInstance* ins;
};
// 会将以下两个对象加载存储在 全局数据区
pthread_mutex_t MyClass::mutex;
SingleInstance* MyClass::ins = nullptr;
```

调用：

```cpp
SingleInstance *single =  SingleInstance::getInstance();
```

