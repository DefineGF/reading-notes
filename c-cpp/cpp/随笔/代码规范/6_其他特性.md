### 6 其他特性

#### 6.1 引用参数

所有按引用传递的参数必须加上 `const`

##### 定义

在 C 语言中, 如果函数需要修改变量的值, 参数必须为指针, 如 `int foo(int *pval)`。在 C++ 中, 函数还可以声明引用参数: `int foo(int &val)`。

##### 优点

定义引用参数防止出现 `(*pval)++` 这样丑陋的代码。像拷贝构造函数这样的应用也是必需的， 而且更明确, 不接受 `NULL` 指针。

##### 缺点

容易引起误解, 因为引用在语法上是值变量却拥有指针的语义。

##### 结论

函数参数列表中, 所有引用参数都必须是 `const`:

```c++
void Foo(const string &in, string *out);
```

事实上这在 Google Code 是一个硬性约定: 输入参数是值参或 `const` 引用, 输出参数为指针。输入参数可以是 `const` 指针, 但决不能是非 `const` 的引用参数，除非用于交换，比如 `swap()`。

有时候，在输入形参中用 `const T*` 指针比 `const T&` 更明智。比如：

- 您会传 null 指针；
- 函数要把指针或对地址的引用赋值给输入形参；

总之大多时候输入形参往往是 `const T&`。 若用 `const T*` 说明输入另有处理。所以若您要用 `const T*`, 则应有理有据，否则会害得读者误解。

#### 6.2 右值引用

只在定义移动构造函数与移动赋值操作时使用右值引用。 不要使用 `std::forward`。

##### 定义

右值引用是一种只能绑定到临时对象的引用的一种, 其语法与传统的引用语法相似。 例如`void f(string&& s)`; 声明了一个其参数是一个字符串的右值引用的函数。

##### 优点

用于定义移动构造函数 (使用类的右值引用进行构造的函数) 使得移动一个值而非拷贝之成为可能。 例如, 如果 `v1` 是一个 `vector<string>`, 则 `auto v2(std::move(v1))` 将很可能不再进行大量的数据复制而只是简单地进行指针操作, 在某些情况下这将带来大幅度的性能提升。

右值引用使得编写通用的函数封装来转发其参数到另外一个函数成为可能, 无论其参数是否是临时对象都能正常工作。

右值引用能实现可移动但不可拷贝的类型, 这一特性对那些在拷贝方面没有实际需求, 但有时又需要将它们作为函数参数传递或塞入容器的类型很有用。

要高效率地使用某些标准库类型, 例如 `std::unique_ptr`, `std::move` 是必需的。

##### 缺点

右值引用是一个相对比较新的特性 (由 C++11 引入), 它尚未被广泛理解。 类似引用崩溃, 移动构造函数的自动推导这样的规则都是很复杂的。

##### 结论

只在定义移动构造函数与移动赋值操作时使用右值引用, 不要使用 `std::forward` 功能函数。你可能会使用 `std::move` 来表示将值从一个对象移动而不是复制到另一个对象。



#### 6.3 函数重载

若要用好函数重载，最好能让读者一看调用点（call site）就胸有成竹，不用花心思猜测调用的重载函数到底是哪一种。该规则适用于构造函数。

##### 定义

你可以编写一个参数类型为 `const string&` 的函数, 然后用另一个参数类型为 `const char*` 的函数重载它:

```c++
class MyClass {
    public:
    void Analyze(const string &text);
    void Analyze(const char *text, size_t textlen);
};
```

##### 优点

通过重载参数不同的同名函数, 令代码更加直观。模板化代码需要重载, 同时为使用者带来便利。

##### 缺点

如果函数单单靠不同的参数类型而重载，读者就得十分熟悉 C++ 五花八门的匹配规则，以了解匹配过程具体到底如何。另外，当派生类只重载了某个函数的部分变体，继承语义容易令人困惑。

##### 结论

如果您打算重载一个函数, 可以试试改在函数名里加上参数信息。例如，用 `AppendString()` 和 `AppendInt()` 等， 而不是一口气重载多个 `Append()`。

#### 6.4 缺省参数

我们不允许使用缺省函数参数，少数极端情况除外。尽可能改用函数重载。

##### 优点

当您有依赖缺省参数的函数时，您也许偶尔会修改修改这些缺省参数。通过缺省参数，不用再为个别情况而特意定义一大堆函数了。与函数重载相比，缺省参数语法更为清晰，代码少，也很好地区分了「必选参数」和「可选参数」。

##### 缺点

缺省参数会干扰函数指针，害得后者的函数签名（function signature）往往对不上所实际要调用的函数签名。即在一个现有函数添加缺省参数，就会改变它的类型，那么调用其地址的代码可能会出错，不过函数重载就没这问题了。此外，缺省参数会造成臃肿的代码，毕竟它们在每一个调用点（call site）都有重复。函数重载正好相反，毕竟它们所谓的「缺省参数」只会出现在函数定义里。

##### 结论

由于缺点并不是很严重，有些人依旧偏爱缺省参数胜于函数重载。所以除了以下情况，我们要求必须显式提供所有参数。

- 位于 `.cc` 文件里的静态函数或匿名空间函数，毕竟都只能在局部文件里调用该函数了；

- 可以在构造函数里用缺省参数，毕竟不可能取得它们的地址；

- 可以用来模拟变长数组：

    ```c++
    // 通过空 AlphaNum 以支持四个形参
    string StrCat(const AlphaNum &a,
                  const AlphaNum &b = gEmptyAlphaNum,
                  const AlphaNum &c = gEmptyAlphaNum,
                  const AlphaNum &d = gEmptyAlphaNum);
    ```



#### 6.5 变长数组和alloca()

我们不允许使用变长数组和 `alloca()`。

##### 优点

变长数组具有浑然天成的语法. 变长数组和 `alloca()` 也都很高效。

##### 缺点

变长数组和 `alloca()` 不是标准 C++ 的组成部分。更重要的是, 它们根据数据大小动态分配堆栈内存, 会引起难以发现的内存越界 bugs: “在我的机器上运行的好好的, 发布后却莫名其妙的挂掉了”。

##### 结论

改用更安全的分配器（allocator），就像 `std::vector` 或 `std::unique_ptr<T[]>`。



#### 6.6  友元

我们允许合理的使用友元类及友元函数。

通常友元应该定义在同一文件内, 避免代码读者跑到其它文件查找使用该私有成员的类。 经常用到友元的一个地方是将 `FooBuilder` 声明为 `Foo` 的友元, 以便 `FooBuilder` 正确构造 `Foo` 的内部状态, 而无需将该状态暴露出来。 某些情况下, 将一个单元测试类声明成待测类的友元会很方便。

友元扩大了 (但没有打破) 类的封装边界。 某些情况下, 相对于将类成员声明为 `public`, 使用友元是更好的选择, 尤其是如果你只允许另一个类访问该类的私有成员时。 当然, 大多数类都只应该通过其提供的公有成员进行互操作。

#### 6.7 异常

我们不使用 C++ 异常。

##### 优点

- 异常允许应用高层决定如何处理在底层嵌套函数中「不可能发生」的失败（failures），不用管那些含糊且容易出错的错误代码。
- 很多现代语言都用异常。引入异常使得 C++ 与 Python, Java 以及其它类 C++ 的语言更一脉相承。
- 有些第三方 C++ 库依赖异常，禁用异常就不好用了。
- 异常是处理构造函数失败的唯一途径。虽然可以用工厂函数或 `Init()` 方法代替异常, 但是前者要求在堆栈分配内存，后者会导致刚创建的实例处于 ”无效“ 状态。
- 在测试框架里很好用。

##### 缺点

- 在现有函数中添加 `throw` 语句时，您必须检查所有调用点。要么让所有调用点统统具备最低限度的异常安全保证，要么眼睁睁地看异常一路欢快地往上跑，最终中断掉整个程序。举例，`f()` 调用 `g()`, `g()` 又调用 `h()`, 且 `h` 抛出的异常被 `f` 捕获。当心 `g`, 否则会没妥善清理好。
- 还有更常见的，异常会彻底扰乱程序的执行流程并难以判断，函数也许会在您意料不到的地方返回。您或许会加一大堆何时何处处理异常的规定来降低风险，然而开发者的记忆负担更重了。
- 异常安全需要RAII和不同的编码实践。 要轻松编写出正确的异常安全代码需要大量的支持机制。 更进一步地说, 为了避免读者理解整个调用表, 异常安全必须隔绝从持续状态写到 “提交” 状态的逻辑. 这一点有利有弊 (因为你也许不得不为了隔离提交而混淆代码). 如果允许使用异常, 我们就不得不时刻关注这样的弊端, 即使有时它们并不值得。
- 启用异常会增加二进制文件数据，延长编译时间（或许影响小），还可能加大地址空间的压力。
- 滥用异常会变相鼓励开发者去捕捉不合时宜，或本来就已经没法恢复的「伪异常」。比如，用户的输入不符合格式要求时，也用不着抛异常。如此之类的伪异常列都列不完。



##### 结论

从表面上看来，使用异常利大于弊, 尤其是在新项目中。 但是对于现有代码, 引入异常会牵连到所有相关代码。如果新项目允许异常向外扩散, 在跟以前未使用异常的代码整合时也将是个麻烦。



#### 6.8 运行时类型识别

禁止使用 RTTI。

##### 定义

RTTI 允许程序员在运行时识别 C++ 类对象的类型。 它通过使用 `typeid` 或者 `dynamic_cast` 完成。

##### 优点

RTTI 的标准替代 (下面将描述) 需要对有问题的类层级进行修改或重构。 有时这样的修改并不是我们所想要的, 甚至是不可取的, 尤其是在一个已经广泛使用的或者成熟的代码中。

RTTI 在某些单元测试中非常有用。 比如进行工厂类测试时, 用来验证一个新建对象是否为期望的动态类型。 RTTI 对于管理对象和派生对象的关系也很有用。

在考虑多个抽象对象时 RTTI 也很好用。 例如:

```c++
bool Base::Equal(Base* other) = 0;
bool Derived::Equal(Base* other) {
  Derived* that = dynamic_cast<Derived*>(other);
  if (that == NULL)
    return false;
  ...
}
```

##### 缺点

在运行时判断类型通常意味着设计问题。如果你需要在运行期间确定一个对象的类型, 这通常说明你需要考虑重新设计你的类。

随意地使用 RTTI 会使你的代码难以维护。 它使得基于类型的判断树或者 switch 语句散布在代码各处。 如果以后要进行修改, 你就必须检查它们。



##### 结论

RTTI 有合理的用途但是容易被滥用, 因此在使用时请务必注意。 在单元测试中可以使用 RTTI, 但是在其他代码中请尽量避免。尤其是在新代码中, 使用 RTTI 前务必三思。如果你的代码需要根据不同的对象类型执行不同的行为的话, 请考虑用以下的两种替代方案之一查询类型:

虚函数可以根据子类类型的不同而执行不同代码。这是把工作交给了对象本身去处理。

如果这一工作需要在对象之外完成, 可以考虑使用双重分发的方案, 例如使用访问者设计模式。这就能够在对象之外进行类型判断。

如果程序能够保证给定的基类实例实际上都是某个派生类的实例, 那么就可以自由使用 dynamic_cast。在这种情况下, 使用 dynamic_cast 也是一种替代方案。

基于类型的判断树是一个很强的暗示, 它说明你的代码已经偏离正轨了。 不要像下面这样：

```c++
if (typeid(*data) == typeid(D1)) {
  ...
} else if (typeid(*data) == typeid(D2)) {
  ...
} else if (typeid(*data) == typeid(D3)) {
```

一旦在类层级中加入新的子类, 像这样的代码往往会崩溃。 而且, 一旦某个子类的属性改变了, 你很难找到并修改所有受影响的代码块。

不要去手工实现一个类似 RTTI 的方案。 反对 RTTI 的理由同样适用于这些方案, 比如带类型标签的类继承体系。 而且, 这些方案会掩盖你的真实意图。