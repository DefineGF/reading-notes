#### 函数调用

##### 问题1

cpp中，函数调用的过程是什么。比如在main函数中调用func：
bool func(int a, int b) { return true; }
int main() { bool ans = func(1, 2); }
编译之后 func 地址是什么，main函数中如何找到func的地址，以及如何传入参数和获取函数返回值的？

> C++函数调用的过程大概分成以下几个阶段:
>
> 1. 编译器生成目标代码时,会为每个函数分配地址空间并记录其地址。对于上面的代码,func的地址会记录在对象文件或库文件中。
> 2. 在main函数内调用func时,编译器会检查func的函数原型,完成参数修饰与类型检查。
> 3. 编译器会生成调用func时需要的机器码,其中包括跳转到func地址的指令,并准备好参数在堆栈上的位置。
> 4. 程序运行时,当遇到func函数调用语句时,CPU就会执行该跳转指令,跳转到func预留的地址空间开始执行。
> 5. func函数内部会把参数从堆栈上弹出到寄存器或者内存变量中使用。执行完返回。
> 6. func函数返回后,会把返回值从 registers 保存回堆栈位置给调用者获取。
> 7. main函数继续执行,从栈位置获取func的返回值到ans变量

继续问：链接的时候，main函数记录func的地址；但是当操作系统载入并运行可执行文件时，main函数并不知道当前程序会存放在哪段虚拟内存？

> 实际上,函数地址在链接时确定的是相对地址,而不是绝对地址。
>
> 当程序加载到内存后,操作系统会为程序分配一个 Loading Address。此时,函数之间的相对地址关系还保持不变,但是它们的绝对地址都需要加上 Loading Address 偏移。
>
> 更确切地说,函数调用的步骤为:
>
> 1. 链接时,func的地址被记录为 main 函数到 func 函数的相对地址偏移。
> 2. 程序加载后,操作系统会选择 program image 的 Loading Address。
> 3. 此时 func 和 main 的绝对地址都需要加上 Loading Address。但二者之间的相对地址偏移保持不变。
> 4. 在 main 函数调用 func 时, CPU 根据链接时记录的相对地址偏移,计算出 func 的当前绝对地址,并跳转执行。
> 5. 参数传递、返回值获取等细节操作基于相对地址。

继续问：func函数是以代码的形式存放在代码段里吗？

> 是的,函数的机器码实际会存放在程序的代码段(code section)中。
>
> 更准确地说,对于一个函数 func:
>
> - 函数 func 的机器码会在编译期间生成,并作为对象代码输出。
> - 连接器会将不同对象文件的代码段合并到可执行文件中的代码段中。
> - func 的机器码就存放在代码段中的固定位置。其他函数也类似。
> - 链接器会记录各个函数的起始地址与长度,生成符号表记录函数之间的引用关系。
> - 当程序加载后,操作系统会为代码段分配内存,各个函数的机器码就 LOAD 到相应的内存地址上。
> - 在调用时,CPU 会通过函数地址跳转到代码段执行对应的机器码。



##### 问题2

那么多次运行同一个可执行文件，内存中加载了多少代码段？

> 对于同一个可执行文件多次运行,内存中只会加载一个代码段。
>
> 具体来说:
>
> - 可执行文件中已经包含了程序所有的代码机器码,链接成一个整体。
> - 当可执行文件首次运行时,操作系统会为程序分配一个最小的内存区域,包括代码段、数据段等。
> - 所有后续运行此同一可执行文件的实例,操作系统会直接重用上一次的内存布局,不会为代码段重新分配内存。
> - 因此所有实例共享一个内存中的代码段区域。代码不会重复加载。
> - 每个新实例只会为自己分配独立的堆栈和数据段等内存。
> - 但函数代码本身只需要在内存中一份即可被所有实例共享调用。
>
> 所以对于 absolutely 相同的可执行文件来说:
>
> - 只会加载一个内存中的代码段
> - 后续运行实例直接重用此代码段
> - 函数地址等资源共享
> - 实例间不会因为代码段重复加载而浪费内存