

### 可执行文件的装载

#### 一、进程创建

##### 1. 创建独立的虚拟地址空间

并不是创建空间而是创建映射函数需要的相应的数据结构；在Linux（i386) 下，只需创建一个页目录就行，设置不用设置映射关系（虚拟空间与物理内存之间的映射关系），这些映射关系等到程序发生页错误时候在进行设置；



##### 2. 读取可执行文件头，建立虚拟空间与可执行文件的映射关系

当操作系统捕获到缺页错误时，操作系统应知道程序当前所需要的页在可执行文件中的哪个位置，即可执行文件与虚拟空间的映射关系。

这种映射关系只是操作系统内部的一个数据结构：进程创建后，OS会在进程相应的数据结构中设置一个.text段的VMA（Linux将进程虚拟空间中的一个段叫做虚拟内存区域（virtual memory area））及在ELF文件中的偏移，还有其他属性。

 

##### 3. 将CPU指令寄存器设置成可执行文件入口，启动运行

OS通过设置CPU的指令寄存器将控制权转交给进程，涉及到：

- 内存堆栈和用户堆栈的切换；
- CPU运行权限的切换；



#### 二、 页错误

进程创建后，可执行文件的真正指令和数据都没有被装入到内存中，而是根据可执行文件头创建起可执行文件与**进程虚拟内存** 之间的映射罢了；

CPU执行到程序入口时，发现页面为空页面，此时将控制权交由操作系统：

1. OS查询到上述创建的数据结构，找到页面所在的VMA，计算出相应的页面在执行文件中的偏移；
2. 然后在物理内存中分配一个物理页面，并将进程中该虚拟页面与物理页面建立映射关系；
3. 控制权交由进程，进程从刚才发生页错误的地方再次执行。



### Linux装载ELF过程

首先在用户层面，bash会调用fork系统调用创建新的进程，执行 execve() 系统调用后，linux内核进行真正的装载工作：

1. 读取文件的前128个字节，通过魔数判断文件类型：比如a.out, a.elf，a.java, a.py；
2. 调用search_binary_handle() 搜索和匹配合适的可执行文件装载处理过程，ELF文件的装载过程叫做 load_elf_binary()；
   1. 检查ELF可执行文件的有效性：魔数、程序头表中段的数量；
   2. 寻找动态链接的".interp" 段，设置动态链接的路径；
   3. 根据文件的程序头表描述，对ELF文件进行映射；
   4. 初始化ELF执行进程环境，比如进程启动时EDX寄存器的地址是DT_FINI的地址；
   5. 将系统调用的返回地址设置为程序的入口地址：如果是静态链接的ELF可执行文件，入口就是ELF文件的文件头中e_entry所指的地址；如果是动态链接的ELF可执行文件，入口就是动态链接器；

当系统调用从内核态返回到用户态时，EIP寄存器直接跳转到ELF程序的人口地址了。

