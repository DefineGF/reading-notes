#### 算法过程

首先是读入棋盘，并放入指定大小的二维整数矩阵中；

其次，根据矩阵中 1 的数量 和 -1 的数量，来判断轮到谁走。一般会有以下几种情况：

-  1 和 -1 的数量均为0，表名棋盘还未落子，这个时候，只要在棋盘的中心区域随机选一个落子坐标即可；

-  1和-1的数量相等，但不等于0：表明轮到先行方（1）下了；

-  1的数量大于-1的数量：表明轮到后行方（-1）下了；

​	注：一般情况下，不会出现先行方数量（1）小于 后行方 （-1）的数量，但是word文档中8 * 8 的棋盘，给出的是1 的数量为 25，-1的数量为 26；

然后遍历棋盘，评估**未落子地方**（0）的得分，简而言之就是该点：越是利于自己 或者 不利于 对方的分越高；所以问题的关键是如何评价该处对自己有利！

- 首先，一个落子点有八个方向，构成四条直线，该点的得分由这四个直线得分之和决定；

- 每条直线的得分和不同棋子的组合状态有关，在五子棋术语中又分为几个阶段：

  - 第一阵营：（已胜）
    - 连5：五个连着
  - 第二阵营：必胜
    - 活4：四个连着且两端没有堵住；下一步可连5
  - 第三阵营：差一手必胜
    - 冲四：比如四个连着但一端被堵住；下一步可 连5
    - 活三：比如三个连着且两端没有被堵住；下一步可 活4
  - 第四阵营：差两手必胜
    - 眠3
    - 活2
  - 第五阵营：差三手胜
    - 眠2
    - 活1

  因此根据同一直线的不同棋子状态，先搜索己方棋子状态，根据不同级别设置不同分数；

  同时搜索对方棋子状态，当对方的评价的分数也高时，可以通过占对方的得分高的空位置避免对方得高分；



#### 代码细节

##### 数据结构

- Bool：有Undefined，True， False 三种状态；
- enum_chess_type：记录落子点状态；
- Point：记录点坐标信息；
- Line：记录直线上棋子信息；



##### 核心算法

- int get_neighbor_type(Point p, int x_off, int y_off, Bool is_next)：获取当前节点 p 指定方向偏移的棋子种类

  也就是说，当x_off = 1, y_off = 1时，获取当前空棋子 右上角棋子的种类：

  - 1：同类；或隔一空格同类；
  - 2：异类；或隔一空格异类；
  - 0：空格

- void init_line_message(Point p, int x_off, int y_off, Bool is_forward)：完善本条直线的信息；

  通过 get_neighbor_type，设置正向 和 反向搜索，比如搜索右上角 和 左下角，完善第一和第三象限直线上棋子信息，保存在Line中；

- int get_line_score(Point p, int x_off, int y_off)：根据本条直线上棋子的状态评估本条直线所得分数；

  在本函数，涉及到针对不同的棋子状态，对直线打分；

- int get_point_score(Point p)：通过遍历该空落子点四个方向上的直线，获取四条直线的评估和作为本节点的最终结果；





#### 运行结果

##### 先测试一下word 所给的 8 * 8 的棋盘

- 设置文件路径：

  ![image-20211212213110066](./C:/Users/cheng/Nutstore/1/JGWorkspace/项目集/五子棋/image-20211212213110066.png)

  其中 ".\\\\"表示在运行 .exe的同一目录下的文件；

   ![image-20211212213231297](./C:/Users/cheng/Nutstore/1/JGWorkspace/项目集/五子棋/image-20211212213231297.png)

- 编译与运行：

  <img src="./C:/Users/cheng/Nutstore/1/JGWorkspace/项目集/五子棋/image-20211212225749297.png" style="zoom:60%" />

    这里使用 gcc 编译，当然也可以复制代码在IDE中运行；

    运行结果：

    - 首先是打印出读入的 二维矩阵；
    - 然后是输出遍历棋盘空落子点的所有非零结果；最终选中的是第2行第6列，即坐标（1,5），试着分析一下（当前执棋为1）：
      - 第2行第6列：右上角和左下角可以连成5，同时，放置在该处还能避免 -1 下一步连成5；（即最有利与自己，最不利于别人）；
      - 同样（3,1）坐标评分也一样很大，即第四排第二列，分析发现，1 置此可以将左上和右下连成5；
      - 同理（5,4）评分甚至大于上一个，仔细分析发现，该点不仅能将水平的1连成5，还能避免两斜边的-1 连成3；

    ##### 提交

    由于要求棋盘大小为 16 * 16， 那么修改代码 SIZE  = 16 即可

















