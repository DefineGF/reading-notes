### Class

#### 获取 Class 对象

- 静态变量

```java
Class strCls = String.class;
```

- 实例变量 getClass()

```java
String s = "";
Class cls = s.getClass();
```

- Class.forName("完整类名")

```java
Class cls = Class.forName("java.lang.String");
```



##### Class对象使用

无参构造函数：

```java
Class cls = String.class;
Stirng s = (String)cls.newInstance(); // 创建一个 String 实例
```

限制：只能调用 public 的无参构造函数；带参数的或者非public的构造函数无法通过 newInstance() 创建；

有参构造函数：

```java
Constructor<Person> constructor = Person.class.getConstructor(String.class, int.class);
Person person = constructor.newInstance("dong", 22);
```



#### Field

##### field 属性

- `getName()`：返回字段名称，例如，`"name"`；
- `getType()`：返回字段类型，也是一个`Class`实例，例如，`String.class`；
- `getModifiers()`：返回字段的修饰符，它是一个`int`，不同的bit表示不同的含义。

实例：

```java
package _field;
public class Person {
    private int age;
    public String name;
    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
    private void setAge(int age) {
        this.age = age;
    }
}
```

```java
private static void logFieldMsg(Field field) {
    System.out.println("current field: " + field);
    System.out.println("\tname = " + field.getName());
    System.out.println("\ttype = " + field.getType());
    System.out.println("\tmodifiers = " + field.getModifiers());
}

public static void main(String[] args) {
    Class pCls = Person.class;
    Field []fields = pCls.getDeclaredFields();
    for (Field field : fields) {
        logFieldMsg(field);
    }
}
```

输出结果：

```java
/**
 * current field: private int _field.Person.age
 *     name = age
 *     type = int
 *     modifiers = 2
 * current field: public java.lang.String _field.Person.name
 *     name = name
 *     type = class java.lang.String
 *     modifiers = 1
 */
```



##### 获取 field

- Field getField(name)：根据字段名获取**某个public**的field（包括父类）
- Field[] getFields()：获取所有**public**的field（包括父类）
- Field getDeclaredField(name)：根据字段名获取当前类的某个field（不包括父类）
- Field[] getDeclaredFields()：获取当前类的所有field（不包括父类）



##### 使用 field

针对 private 变量，应使用 setAccessible(true) 来指示 可修改其值

```java
Field ageField = pCls.getDeclaredField("age");
ageField.setAccessible(true);
ageField.set(person, 22);
```



#### Method

##### Method属性

- `getName()`：方法名称
- `getReturnType()`：方法返回值类型，Class 类型
- `getParameterTypes()`：方法的参数类型，Class数组，
- `getModifiers()`：返回方法的修饰符，它是一个`int`



##### 获取Method

- `Method getMethod(name, Class...)`：获取某个`public`的`Method`（包括父类）
- `Method getMethod(name, Class...)`：获取某个`public`的`Method`（包括父类）
- `Method[] getMethods()`：获取所有`public`的`Method`（包括父类）
- `Method getDeclaredMethod(name, Class...)`：获取当前类的某个`Method`（不包括父类）
- `Method[] getDeclaredMethods()`：获取当前类的所有`Method`（不包括父类）



##### 调用实例

```java
Method setAgeMethod = person.getClass().getDeclaredMethod("setAge", int.class);
setAgeMethod.setAccessible(true);
setAgeMethod.invoke(person, 22);
```





#### 综合回顾

原始类：

```java
public class Person {
    private String name;
    private int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public void sayHello() {
        System.out.println("Hello, my name is " + name + " and I'm " + age + " years old.");
    }
}
```

##### 通过反射创建对象

```java
// 使用反射动态创建 Person 对象并调用 sayHello 方法
try {
    // 获取 Person 类的 Class 对象
    Class<?> personClass = Class.forName("com.example.Person");
    // 获取 Person 类的构造函数
    Constructor<?> constructor = personClass.getConstructor(String.class, int.class);
    // 创建 Person 对象
    Object person = constructor.newInstance("Alice", 25);
    // 获取 sayHello 方法
    Method sayHelloMethod = personClass.getMethod("sayHello");
    // 调用 sayHello 方法
    sayHelloMethod.invoke(person);
} catch (Exception e) {
    e.printStackTrace();
}
```



##### 访问并修改私有字段

```java
// 使用反射访问和修改私有字段
try {
    // 获取 Person 类的 Class 对象
    Class<?> personClass = Class.forName("com.example.Person");
    // 创建 Person 对象
    Object person = personClass.getConstructor().newInstance();
    // 获取私有字段 name
    Field nameField = personClass.getDeclaredField("name");
    // 设置可访问标志为 true,以便可以访问私有字段
    nameField.setAccessible(true);
    // 设置 name 字段的值
    nameField.set(person, "Alice");
    // 获取 name 字段的值
    String name = (String) nameField.get(person);
    System.out.println("Name: " + name);
} catch (Exception e) {
    e.printStackTrace();
}
```



##### 动态加载类并执行方法

使用反射动态加载一个类并执行其方法。通过反射,我们可以在运行时根据类名加载类,并创建其实例,然后调用其方法。这在插件系统或动态扩展的场景中非常有用。

```java
// 假设有一个名为 MyPlugin 的接口
public interface MyPlugin {
    void execute();
}
// 使用反射动态加载类并执行方法
try {
    // 从配置文件或其他来源获取类名
    String className = "com.example.MyPluginImpl";

    // 加载类
    Class<?> pluginClass = Class.forName(className);

    // 创建类的实例
    MyPlugin plugin = (MyPlugin) pluginClass.getConstructor().newInstance();

    // 执行插件的方法
    plugin.execute();
} catch (Exception e) {
    e.printStackTrace();
}
```



##### 对象复制

使用反射实现了一个通用的对象复制方法。通过反射,我们可以在运行时获取对象的类型信息,并通过遍历其字段来复制对象的状态。这个方法可以用于任意类型的对象,而无需为每个类编写特定的复制方法。

```java
public static <T> T copyObject(T source) {
    try {
        // 获取源对象的类型
        Class<?> clazz = source.getClass();

        // 创建目标对象
        T target = (T) clazz.getConstructor().newInstance();

        // 遍历源对象的所有字段
        for (Field field : clazz.getDeclaredFields()) {
            // 设置字段可访问
            field.setAccessible(true);

            // 获取字段的值
            Object value = field.get(source);

            // 将字段的值复制到目标对象
            field.set(target, value);
        }
        return target;
    } catch (Exception e) {
        throw new RuntimeException("Object copy failed", e);
    }
}
```

