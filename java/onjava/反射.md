#### 获取Class

```java
public interface Calculator {
    int add(int a, int b);
    int subtract(int a, int b);
}

public class CalculatorImpl implements Calculator {
    @Override
    public int add(int a, int b) {
        return a + b;
    }
    @Override
    public int subtract(int a, int b) {
        return a - b;
    }
}

Calculator calculator = new CalculatorImpl();
```

获取Class方法：

- calculator.getClass()
- CalculatorImpl.class
- Class.forName("com.cjm.onjavabasic._proxy.CalculatorImpl")



##### calculator.getClass()

必须先创建类的实例对象,然后通过该对象调用getClass()方法；

> 尽管 `calculator` 也是由 `CalculatorImpl` 类实例化的，但是它被声明为 `Calculator` 接口类型。不过，它仍然是 `CalculatorImpl.class`。这是因为 `getClass()` 方法返回的是实际运行时对象的具体类，而不是变量的声明类型。
>
> **运行时类型信息：**
>
> - Java 对象在内存中有一个类元数据的引用，这部分数据包含了关于类的详细信息，包括类名、方法、属性等。
> - 当调用 getClass() 方法时，它实际上是直接访问这个内部的类元数据来返回对象的实际运行时类。
>
> 如：
>
> ```java
> Object obj = new String("Hello");
> Class<?> cls = obj.getClass();
> System.out.println(cls.getName());  // 输出 java.lang.String
> ```

getClass() 底层实现：

- **获取对象头**：每次对象的 `getClass()` 方法被调用时，JVM 首先访问该对象的对象头；
- **访问类元数据**：从对象头中读取指向类元数据的指针；
- **返回Class对象**：使用从对象头中获取的指针，找到对应的 `Class` 对象，并将其返回。

特殊情况：动态代理

```java
Calculator calculator = (Calculator) Proxy.newProxyInstance(
    Calculator.class.getClassLoader(),
    new Class<?>[] { Calculator.class },
    new InvocationHandler() {
        private CalculatorImpl calculatorImpl = new CalculatorImpl();
        @Override
        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
            // 可以在这里添加额外的逻辑
            return method.invoke(calculatorImpl, args);
        }
    });
Class<? extends Calculator> cls = calculator.getClass();
// calculator.getClass() 将不会返回 CalculatorImpl.class，而是返回一个由 Proxy 类动态生成的类: com.sun.proxy.$Proxy0
```

