

#### Hash算法

##### 常见

| 算法       | 输出长度（位） | 输出长度（字节） |
| :--------- | :------------- | :--------------- |
| MD5        | 128 bits       | 16 bytes         |
| SHA-1      | 160 bits       | 20 bytes         |
| RipeMD-160 | 160 bits       | 20 bytes         |
| SHA-256    | 256 bits       | 32 bytes         |
| SHA-512    | 512 bits       | 64 bytes         |

##### 用处

同一输入则输出不变；

- 验证下载文件正确

  如何判断下载到本地的软件是原始的、未经篡改的文件？

  我们只需要自己计算一下本地文件的哈希值，再与官网公开的哈希值对比，如果相同，说明文件下载正确，否则，说明文件已被篡改。

- 存储用户密码

  在用户输入原始口令后，系统计算用户输入的原始口令的MD5并与数据库存储的MD5对比，如果一致，说明口令正确，否则，口令错误。



#### 对称加密算法

用一个密码进行加密和解密；

对称加密算法决定了口令必须是固定长度，然后对明文进行分块加密。又因为安全需求，口令长度往往都是128位以上，即至少16个字符

加密：明文 & 密码 ->  密文；

解密：密文 & 密码 -> 明文

##### 分类

| 算法 | 密钥长度    | 工作模式             | 填充模式                                |
| :--- | :---------- | :------------------- | :-------------------------------------- |
| DES  | 56/64       | ECB/CBC/PCBC/CTR/... | NoPadding/PKCS5Padding/...              |
| AES  | 128/192/256 | ECB/CBC/PCBC/CTR/... | NoPadding/PKCS5Padding/PKCS7Padding/... |
| IDEA | 128         | ECB                  | PKCS5Padding/PKCS7Padding/...           |

DES算法由于密钥过短，可以在短时间内被暴力破解，所以现在已经不安全了



##### AES加密（Advanced Encryption Standard）

- ECB模式加密

  只需要一个固定长度的密钥，固定的明文会生成固定的密文，这种一对一的加密方式会导致安全性降低

- CBC 模式

  它需要一个随机数作为IV参数，这样对于同一份明文，每次生成的密文都不同；



#### 口令加密（Password Based Encrypted）

实际上用户输入的口令并不能直接作为AES的密钥进行加密（除非长度恰好是128/192/256位）；

因此，用户输入的口令，通常还需要使用PBE算法，采用随机数杂凑计算出真正的密钥，再进行加密；

**PBE算法内部使用的仍然是标准对称加密算法（例如AES）。**



#### 密钥交换算法

##### 算法步骤

1. 甲选择一个素数`p`，底数`g`，随机数`a`，然后计算**A=g^a mod p**，

   比如  p = 509,	g = 5,	a = 123, 	则 A = 215； 然后，甲发送 p＝509， g=5，A=215给乙；

2. 乙方收到后，选择一个随机数`b`，计算  **B=g^b mod p**；然后再计算  **s=A^b mod p**；

   比如，b = 456，则 B = 181， s = 121；

3. 乙把计算的 B=181 发给甲，甲计算  **s＝B^a mod p** 的余数，计算结果与乙算出的结果一样，都是121

4. 最终双方协商出的密钥为：121。

相关公式：

>甲：A=g^a mod p
>
>乙：B=g^b mod p
>
>​	    s=A^b mod p
>
>甲：s＝B^a mod p



更确切地说，DH算法是一个密钥协商算法，双方最终协商出一个共同的密钥，而这个密钥不会通过网络传输

把`a`看成甲的私钥，`A`看成甲的公钥，`b`看成乙的私钥，`B`看成乙的公钥，

DH算法的本质就是双方各自生成自己的私钥和公钥，私钥仅对自己可见，

然后交换公钥，并根据自己的私钥和对方的公钥，生成最终的密钥`secretKey`，DH算法通过数学定律保证了双方各自计算出的`secretKey`是相同的。



#### 非对称加密算法

非对称加密就是加密和解密使用的不是相同的密钥：只有同一个公钥-私钥对才能正常加解密。

公钥密码体制三个应用：

- 加密/解密
- 数字签名：发送方使用其私钥对消息“签名”，
- 密钥交换

##### 相对于对称加密

- 缺：运行慢；

- 优：无需协商密钥

  非对称加密可以安全地公开各自的公钥，N人通信时：非对称加密只需要N个密钥对，每个人只管理自己的密钥对；

  而使用对称加密需要则需要`N*(N-1)/2`个密钥，因此每个人需要管理`N-1`个密钥，密钥管理难度大，且容易泄漏。



##### RSA 经典 非对称加密算法

null



##### 实际应用

在实际应用的时候，非对称加密总是和对称加密一起使用。

假设小明需要给小红需要传输加密文件，他俩首先交换了各自的公钥，然后：

1. 小明生成一个随机的AES口令，然后用小红的公钥通过RSA加密这个口令，并发给小红；
2. 小红用自己的RSA私钥解密得到AES口令；
3. 双方使用这个共享的AES口令用AES加密通信。



#### 补充：Hash 函数

Hash函数将可变长度的数据块作为输入，产生固定长度的Hash值 h = Hash（M)

##### 要求

以下情况计算上不可行：

- 单向性：对预先指定的Hash值找到对应的数据块；
- 抗碰撞性：找到两个不同的数据块对应相同的hash值；



#### 应用

##### 消息认证

- 确保接收到的数据确实和发送时一样（没有修改、插入、删除或者重放）；

- 确保发送方声称的身份是真实有效的；

过程：

1. 发送者根据待发送的消息使用该函数计算一组hash值，并将值和消息一起发送过去；
2. 接收者对于消息执行同样的Hash计算，并将结果与收到的hash值进行对比，若不匹配：
   - 消息遭到了篡改
   - hash遭到了篡改

改进：

- 使用对称加密算法加密消息和Hash码；前者提供保密，后者实现认证功能；
- 使用对称加密只对Hash码进行加密，排除了Hash遭到篡改的可能，对于无需保密性的应用，减少了加密解密的操作；
- 不使用加密算法，而是发送方将消息和两者共享的秘密值S进行Hash计算值，并将Hash置于消息尾部；接收方通过S和消息对Hash进行验证；
- 在上一改进的基础上，对消息和Hash进行加密，保证加密性；



##### 数字签名

使用用户的私钥加密消息的Hash值，任何知道该用户公钥的人都能够通过数字签名来验证消息的完整性；

如果既希望保密性又希望有数字签名，则先用发送方的私钥对Hash码进行加密，再用对称加密中的密钥对消息和公钥算法加密结果进行加密；