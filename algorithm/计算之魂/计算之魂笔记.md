### 编码问题

#### 分割黄金

> 雇主有个任务需要7天完成；雇员要求每次都能得到 1/7的黄金；
>
> 如果只能切2刀，如何分割？

分割成 1/7, 2/7, 4/7:

1. 第一天支付 1/7;
2. 第二天雇主支付 2/7, 雇员找回 1/7;
3. 第三天雇主支付1/7
4. 第四天雇主支付4/7, 雇员找回 3/7 (1 + 2 / 7)
5. 第五天雇主支付1/7,
6. 第六天雇主支付2/7, 雇员找回1/7
7. 第七天雇主支付1/7



#### 小白鼠与毒药问题



#### 玻璃球问题

> 玻璃球在某层楼及以上会摔碎，低于该楼高度则不会。给两个玻璃球，使用最少的次数找到摔碎的楼层阈值！

##### 直接

从1层开始试，平均需要50次（但是只需要一个玻璃球）；



##### 答案

第一个玻璃球用于第一次遍历：1-10；11-20；21-30 等等；当30层摔碎时，表明阈值在21-30之间；

第二个玻璃球用于在21-30之间遍历；

平均测试次数：5 + 5；



##### 注

不可使用二分法：

阈值大于 50 或者 <= 50 的概率为 1/2：当首次50层未摔碎时，还是要层层遍历；



### 递归问题

#### 抢20问题

> 两人中一人首先从1和2中选出一个作为起始；
>
> 另一个人在此基础上选择 + 1 或者 +2；
>
> 首先获得 20 者获胜！

反推：

1. 获取20者获胜，则当获取17时，对方无论 +1 还是 +2，自己都会获胜；
2. 获取17者获胜，则当获取14时，对方无论 +1 还是 +2，自己都会获取17，即最终获胜；

递推得知：谁首先获取2，则必会获胜。



#### 上台阶问题

> 从第1级开始，每次选择+1或者+2，最终登上 n 级有多少种方法？

F(n) = F(n - 1) + F(n - 2)

- F(n) 表示 登上第 n 级的方法数；
- 登上 n 级上次可以是从 第n-1级，也可以从第n-2级： 第 n - 1 级的方法数 + 第 n-2级的方法数；



### 分治思想

#### 25 名选手选出前3名

> 一共25名选手，每次比赛只能有5名选手参与。如果要选出前三名，至少需要比赛多少次？

一共需要7次即可

1. 首先将25名选手分为5组，5次比赛决定出每组的次序，假设第一组 a1 > a2 > ... a5；第二组 b1 > b2 > ... > b5；等等
2. 第 6 次比赛，将每组的第一名，即a1、b1、、、e1 进行一次比赛，可以得到第一名，假设是 a1；

此时冷静分析，现已确定：

- a1 > b1 > c1 > d1 > e1
- a1 > a2 > a3 > a4 > a5
- b1 > b2 > ... > b5

选出前3名，则剩余的两个名额将在：a2, a3, b1, b2, c1 中决出。(d1, e1 没有资格了)

因此最后一次比赛，a2, a3, b1, b2, c1 参与即可。



#### 从N个排好序的序列中选出K个最大的元素

##### 简单方法

遍历K次，每次做N次比较，从N个序列中选出当前最大的元素，并记录位置；

时间复杂度：O(KN)；

空间复杂度：O(N)； 用以记录当前序列比较的位置



##### 进阶方法

创建长度为N的大根堆，初始化堆需要 O(NlogN)；其中堆的元素是 <序列值，所在序列索引>

碓顶元素为最大值，记录下来之后，插入该元素所在序列的下一个元素，调整，所用时间：O(logN)

共需要调整K次，即 O(KlogN)；

一共花费时间：O((N+K) \* logN)



#### 未排序的序列中N个元素，找到最大的K个元素

##### 简单方法

排序，时间复杂度：O(NlogN)

##### 进阶算法

维护一个大小为 K+1 的 **小根堆**；
遍历数组出现大于堆顶元素的值，则删除堆顶元素，并插入新的元素，调整；O(logK)
遍历完毕之后，除去堆顶, 剩余K即为最大的K个元素；
时间复杂度: O(NlogK);



#### 未排序的序列中N个元素，找到中值

##### 直接方法

排序；

##### 稍微进阶

按照上一方法中使用的堆算法，时间复杂度为：O(Nlog(N/2))；

##### 认真进阶

快速排序思想，找到下标索引在 (len - 1) / 2 即可



#### 超大数组，多主机寻找中值

> 假设有个很大的数组，分散在 P 个主机上，如何找出这个大数组的中值？

步骤：

1. 随机挑选一个数字作为枢值，发送给每个服务器；
2. 每个服务器根据这个枢值进行比较，第一台得到的结果：
   - 小于等于该值的有 m1 个
   - 大于该值的有 n1 个
3. 其他服务器的结果分别是(m2, n2)，（m3, n3)
4. 最终比较 （m1 + m2 + m3 + ... + mp) 和 (n1 + n2 + n3 + ... + np)
   - 如果前者较大，说明小于该枢值的数字过多，应将枢值减小；
   - 如果后者较大，同理；

