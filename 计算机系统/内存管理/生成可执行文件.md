##### 生成可执行文件（深入理解计算机系统）

- 预处理：hello.c -> hello.i

    gcc -E hello.c -o hello.i

    预处理根据 # 命令：

    - #define MAX 10 将代码中 MAX 全部替换成 10
    - #include<stdio.h> 将stdio中内容直接插入 源文件

- 编译阶段 hello.i -> hello.s

    gcc -S hello.i -o hello.s

    将文本文件 hello.i 翻译成文本文件 hello.s

- 汇编

    gcc -C hello.s -o hello.o

    汇编器将hello.s 转化为 可重定位目标程序 hello.o (二进制形式；机器语言程序)

    目标文件纯粹是字节块的集合，这些块包含程序代码、程序数据，还有包含引导链接器和加载器的数据结构；

- 链接

    gcc hello.o -o hello.exe

    比如hello.c 调用 printf 函数，printf存在于printf.o 目标文件中（单独预编译）；

    链接负责这种合并，最终得到可执行文件
    
    

##### 概念上

- 编译：源代码 -> 目标模块

- 链接：目标模块 & 库文件 -> 装入模块 

    - 静态链接
        - 符号解析：目标文件定义、引用符号每个符号对应一个函数、一个全局变量或者一个静态变量；符号解析的目的是将每个符号引用和一个符号定义关联起来；
        - 重定位：编译器和汇编器生成地址0开始的代码和数据节；链接器通过把每个符号定义与一个内存位置相关联起来，从而重定位这些节。然后修改所有对这些符号的引用，使他们指向这个内存位置；
    - 装入时动态链接
    - 运行时动态链接

- 装入：转入模块 -> 内存

    - 绝对装入

    - 可重定位装入（静态重定位）

        一个问题装入内存时，须分配要求的全部内存（无足够内存则装入失败）；

        装入内存后不可移动 & 申请内存；内存需连续；

    - 动态运行时装入（动态重定位）

        - 装入内存时，地址不修改（相对地址）；
- 装入后再移动亦无所谓，方便存储器紧缩和解决碎片问题；
        - 可移动；动态申请内存



#### 目标文件

- 可重定位目标文件：包含二进制代码和数据，其形式在编译时可以与其他可重定位目标文件合并起来，形成可执行目标文件；

- 可执行目标文件：包含二进制代码和数据，可以被直接复制进内存执行；
- 共享目标文件：一种特殊类型的可重定位目标文件，可以在**加载或者运行时**被动态地加载进内存并链接；

编译器和汇编器生成可重定位目标文件或者共享目标文件；

链接器生成可执行目标文件；


