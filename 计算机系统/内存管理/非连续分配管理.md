

### 非连续分配管理

根据分区大小是否固定：

- 分页存储管理：

    根据运行作业时是否把作业的**所有**页面都装入内存：

    - 基本分页存储管理
    - 请求分页存储管理

- 分段存储管理：

页式存储管理能够有效地提高内存利用率，而分段存储管理能够反映程序的逻辑结构并有利于段的共享；



#### 基本分页存储管理

##### 基本概念

进程：页；内存：页框/帧；外存：块

页表寄存器：

- 页表起始地址：用于根据页号的起始地址和偏移大小确定页表项地址；
- 页表长度：用于判断有无越界



##### 地址结构

页号  + 页内偏移

每个进程有个页表，存放在内存中：页号 <--> 物理内存块号



##### 地址转换

转换过程由硬件完成：

1. 通过逻辑地址A，页面大小L，得到页号 = A / L, 偏移 = A % L；

2. 通过页表起始地址，页号和页表项大小，得到对应的页表项地址 = 起始地址 + 页号 * 页表项大小；

3. 根据页表项得到页号对应的物理块号；

4. 通过块号 和 页内偏移 得到 物理地址。

    

##### 二级分页

顶级页表最多只有一个页面，

逻辑地址格式：一级页号 & 二级页号 & 页内偏移

- 页表初址 + 一级页号 * 页表项大小   ---> 二级页号所在页表于内存中始址；
- 二级页表实址 + 二级页号 * 页表项大小 --> 页表项 -> 物理块号



##### 快表

并行查找能力的高速缓冲寄存器，又称相联存储器（TLB）；

存放若干页表项

注意：

- 分页存储管理汇总的页表项中的页号是隐含的，页表项中无需显式的存放页号；
- 但是快表是某些页表项，不必连续也不必从头开始，因此需要显式存储：（页号：物理块号）；且需要依次查找；
- 快表并非位于内存中，而是位于高速缓冲器中；





#### 基本分段存储管理方式

按照用户进程总自然段划分逻辑空间；段内连续，段间可以不连续；

- 段表项：段号 + 段长 + 本段在主存的始址；

- 段表寄存器：存放段表始址 + 段表长度（段表项个数）；

##### 地址变换

1. 逻辑地址中前几位为段号，后几位为段内偏移；
2. 比较段号 和 段表长度，前者大于后者则产生越界中断；
3. **段表项地址**：段表始址 + 段号 * 段表项长度；
4. 取出段表项中段长与段内偏移比较，后者大于前者产生越界中断；
5. 物理地址：段表项 -> 本段内存始址 + 段内偏移；

**在段式系统中，段号和段内偏移量必须由用户显式提供，在高级程序设计语言中，该工作由编译程序完成**



##### 共享与保护

- 共享：两个作业的段表中相应表项指向被共享的段的同一物理副本实现的；

    （不能修改的代码：纯代码 or 可重入代码）

- 保护：

    - 页：只需判断页号是否越界，页内偏移是不可能越界的；（一次）
    - 段：先判断段号与段表长度；再判断段内偏移与段长；（两次）





#### 段页式管理方式

- 逻辑地址结构：段号 + 页号 + 页内偏移量
- 段表项：段号 + 页表长度 + 页表始址  
- 段表寄存器：段表始址 + 段表长度；

系统为每个进程建立一张段表，每个分段有一个页表；（一个进程只有一个段表，但是页表可能有好多个）；





