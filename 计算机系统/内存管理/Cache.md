## Cache

### Cache映射

由SRAM构造，保存主存汇总最活跃的若干块的副本；

#### 直接映射

主存中每个块都唯一映射到Cache中的块；

##### 映射原理

j = i % 2 <sup>c</sup>；	

其中：i 是 主存块号；j 是 Cache 块号（又称行数）；2 <sup>c</sup>是Cache块数；

##### 地址结构

标记 + Cache 行号 + 块内地址；

- 标记

    当c = 4时：xxxx0001 和 yyyy0001都会映射到 0001 号cache块；

    因此为区别两者，需要记录标记：xxxx 和 yyyy



##### 翻译过程

1. 根据 Cache 行号，找到对应的Cache行号（start + offset）
2. 根据Cache中标记 与 地址中高位做比较：
    - 若相等且有效位为1，则命中：根据块内地址在Cache中寻找数据；
    - 否则，CPU将地址指向的块调入Cache中，并设置有效位为1；



#### 全连接映射

主存中任意一块可以映射到Cache中任意一空闲块；



##### 地址结构

标记 + 块内地址



##### 缺点

寻找目的Cache块需要从头开始查找所有Cache块，直到标记匹配为止；通常采用按内容寻址的昂贵的相联存储器；



#### 组相联映射

组间直接映射；组内全相联映射

每组有n个Cache行，称为n路组相联；



##### 地址结构

标记 + Cache组号 + 块内地址

组号：j = i % Q; 

其中 i 为 主存块号；Q是Cache组数



##### 效果分析

- 组数越多，则路数越少，则块被映射到Cache中的范围越小；同时冲突增大，越接近与直接映射；
- 组数越少，则路数越多，则块可被映射到的范围越大，但相联存储器比较电路更复杂，越接近与全相联映射；





### Cache块替换

#### 常用算法

随机法，先进先出算法，近期最少使用（LRU），最不经常使用（LFU，访问次数最少）



##### LRU

- 硬件实现

    每个Cache行有个计数器，初始为0；

    - 未命中有空闲行，新装入行计数器set 0，其余++；
    - 未命中也没空闲行，值为容量的块淘汰，新晋者为0；
    - 命中时，比其低者++，命中者set 0；（相当于把节点提到前面，他前面的自然先后移动1b）



### Cache读写策略

#### 写策略

##### 写命中

- 全写法：又名写直通法（write-through)

    同时写入Cache块和内存；

- 写回法：write-back

    设有标注位；

    写命中时，只修改Cache内容；只有换出时根据脏位情况写会内存；减少访存次数



##### 写不命中

- 写分配法

    加载主存中的块到Cache中，并更新Cache块；

- 非写分配法

    只写入内存；

通常写回法和写分配法配合；

全写法和非写分配法配合；



#### 多级Cache

CPU <--> 一级Cache <--> 二级Cache <--> 主存

一级Cache：全写法，速度较快；

二级Cache：写回法，相较于主存，二级Cache速度也很快哦；





### 相关细节

##### 容量

总容量 = 存储容量 + 相关位；

- 有效位：1b
- 标记位：主存块号部分（直接/组相联映射） 或者 全部（全相联映射）
- 脏位/一致性维护位：反应此块是否被CPU修改过；
- 替换算法控制位

##### 平均访问时间

- 同时访问Cache 和 主存（前者命中，后者终止）

    T = H * t<sub>c</sub>  + (1 - H) * t<sub>m</sub>	; 	H 表示命中率

- 先Cache 后 主存

    