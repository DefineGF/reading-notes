### 死锁



##### 死锁条件（需全满足）

- **互斥条件**

- **不剥夺条件**：只能由获得该资源的进程释放；

  应对：请求的新资源得不到满足时，必须释放已经保持的所有资源；反复的申请和释放资源会增加系统开销，降低系统吞吐量；（常用于状态易于保存和恢复的资源，比如CPU寄存器资源和内存资源）

- **请求并保持**：请求的资源被请他进程占有，但自己占有的资源不释放；

  应对：静态分配：运行前一次申请完所需要的全部资源；

- **循环等待**



#### 处理

##### 死锁预防：

破坏上述任一条件即可



##### 死锁避免：系统安全状态 | 银行家算法

- 安全状态

  并非所有的不安全状态都是死锁状态；系统处于安全状态，系统便可避免进入死锁状态；

- 银行家算法：

  1. Request <= Need：to 2; 否则 出错；
  2. Request <= Aviable：to 3；否则 等待；
  3. 分配：
     - Available -= Request；
     - Allocation += Request；
     - Need -= Request；

  系统安全性算法：安全：正式分配；不安全：恢复试探分配前状态；



##### 死锁检测 & 解除

检测方法：资源图；

1. 找出既不阻塞又不孤点的进程（与之相连的有向边对应资源的申请数量小于等于系统中已有的空闲资源数量），然后释放其所有资源（使之称为孤点）；
2. 或可唤醒某些阻塞的进程；

若能消去图中所有的边，则该图是可以完全简化的。

解除：

- 资源剥夺法：挂起死锁进程，抢占资源；
- 撤销进程法：撤销部分或者全部
- 进程回退法：设置还原点，让一个或者多进程回退到足以回避死锁的地步；



