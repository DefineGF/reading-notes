### HTTP

#### http 1.0

##### Keep-Alive & Content-Length

⼀个页⾯上有⼏⼗个资源⽂件是很常见的事，连接的建⽴、关闭都是耗时操作，每来⼀个请求就开⼀个TCP连接是⾮常耗时的。

Keep-Alive机制来实现TCP连接的复⽤：

- 客户端在HTTP请求的头部加上⼀个字段Connection：Keep-Alive；

- 服务器收到带有这样字段的请求，在处理完请求之后不会关闭连接，同时在HTTP的Response⾥⾯也会加上该字

  段，然后等待客户端在该连接上发送下⼀个请求；



问题1：连接何时关闭？

> 服务器会有⼀个Keep-Alive timeout参数，过⼀段时间之后，如果该连接上没有新的请求进来，则连接就会关闭；



问题2：客户端如何判断结束？比如请求一个大文件，响应是分批次的，如何判断文件接收完毕？

> 在HTTP Response的头部，返回了⼀个Content-Length 字段。
>
> 这个字段可以告诉客户端HTTP Response的Body共有多少个字节，客户端接收到这么多个字节之后，就知道响应成功接收完毕



#### http 1.1

把连接复⽤变成了⼀个默认属性。即使不加Connection：Keep-Alive属性，服务器也会在请求处理完毕之后不关闭连接。除⾮在请求头部显⽰地加上 Connection：Close 属性，服务器才会在请求处理完毕之后主动关闭连接。



##### Transfer-Encoding：chunked

如果服务器返回的数据是动态语⾔⽣成的内容，则要计算Content-Length，也需要服务器在内存中渲染出整个页⾯，然后计算长度，⾮常耗时。因此引入 Transfer-Encoding：chunked。

其⽬的是告诉客户端，响应的Body是分成了⼀块块的，块与块之间有间隔符，所有块的结尾也有个特殊标记；最后的数字0表⽰整个响应的末尾。



##### Pipeline 

在同⼀个连接上，请求是串⾏的，客户端发送⼀个请求，收到响应，然后发送下⼀个请求，再收到响应。这种串⾏的⽅式，导致并发度不够，因此引入 Pipeline 。

在同⼀个TCP连接上⾯，可以在⼀个请求发出去之后、响应没有回来之前，就可以发送下⼀个、再下⼀个请求，这样就提⾼了在同⼀个TCP连接上⾯的处理请求的效率。



##### Head-of-line Blocking：队头阻塞

客户端发送的请求顺序是 1、2、3，虽然服务器是并发处理的，但客户端接收响应的顺序必须是 1、2、3，如此才能把响应和请求成功配对，跟队列⼀样，先进先出。

> 在绝大多数情况下，一个 HTTP 连接对应一个 TCP 连接。当客户端发起一个 HTTP 请求时，客户端和服务器之间会建立一个 TCP 连接。该 TCP 连接会在请求和响应之间保持打开状态，以便进行双向的数据传输。在这个 TCP 连接上，可以通过多个 HTTP 请求和响应来进行交互。
>
> 然而，也有一些特殊情况下**一个 HTTP 连接可能对应多个 TCP 连接**。例如，一些代理服务器会在客户端和目标服务器之间建立多个 TCP 连接，以提高并发性能或者实现负载均衡。

⼀旦队列头部请求1发⽣延迟，客户端迟迟收不到请求1的响应，则请求2、请求3的响应也会被阻塞；比如请求1和请求2、3不在同一个TCP连接上，导致请求1迟迟没有响应。



##### 断点续传

客户端⼀边下载⼀边记录下载的数据量⼤⼩，⼀旦连接中断了，重新建⽴连接之后，在请求的头部加上Range：fifirst offset-last offset 字段，指定从某个offset下载到某个offset，服务器就可以只返回（fifirst offset，last offset）之间的数据。



##### 推送问题

- 客户端定期轮询：⽐如客户端每5s向服务器发送⼀个HTTP请求，服务器如果有新消息，就返回；
- WebSocket：基于TCP；
- HTTP长轮询：（目前最常用）
  - 客户端发送⼀个HTTP请求，如果服务器有新消息，就⽴即返回；
  - 如果没有，则服务器夯住此连接，客户端⼀直等该请求返回。然后过⼀个约定的时间之后，如果服务器还没有新消息，服务器就返回⼀个空消息（客户端和服务器约定好的⼀个消息）。客户端收到空消息之后关闭连接，再发起⼀个新的连接，重复此过程；



##### 其他优化

对于⼀个域名，浏览器会限制只能开6～8个http连接。

- Spriting：假设在⼀个⽹页⾥，要从服务器加载很多的⼩图⽚（⽐如各种⼩图标），可以在服务器⾥把⼩图⽚拼成⼀张⼤图，到了浏览器，再通过JS或者CSS，从⼤图中截取⼀⼩块显⽰；

- inlining：它将图⽚的原始数据嵌⼊在CSS⽂件⾥⾯；

- js 拼接：把⼤量⼩的JS⽂件合并成⼀个⽂件并压缩；

- 请求的分片技术：⽹站的静态资源（img，js，css）可能都在CDN上⾯，可以做⼀批CDN的域名，这样浏览器就可以为每个域名都建⽴6～8个连接，从⽽提⾼页⾯加载的并发度；

  



#### http/2

##### 兼容 http1.1

HTTP/2和HTTP1.1并不是处于平级的位置，⽽是处在HTTP1.1和TCP之间。以前HTTP 1.1直接构建在TCP之上；现在相当于在HTTP 1.1和TCP之间多了⼀个转换层，这个转换层就是SPDY，也就是现在的HTTP/2。



##### 二进制分帧

每个请求在发送之前被转换成⼆进制，然后分成多个帧发送；每个响应在回复之前，也被转成了⼆进制，然后分成多个帧发送；

> 例如：请求1被分成了F1、F2、F3三个帧；请求2被分成了F4、F5两个帧；请求3被分成了F6、F7两个帧；F1～F7是被乱序地发送出去的，到了服务器端被重新组装。同理，响应1、2、3也是同样的过程。
>
> 有三条流、三个流ID，分别打到三条流⾥⾯每⼀个帧上。



