## 数据库

#### 分库分表

通过将数据分散存储在多个数据库实例（分库）和表中（分表），可以提高系统的并发处理能力和数据的存储容量。

- 业务拆分与扩展：通过RPC或消息中间件通信，既便于团队成员的职责分⼯，也便于对未来某个系统进⾏扩展；
- 应对高并发：
  - 如果是读多写少，可以通过加从库、加缓存解决；
  - 如果是读少写多，或者说写⼊的QPS已经达到了数据库的瓶颈，这时就要考虑分库分表了；
- 数据隔离：如果把核⼼业务数据和⾮核⼼业务数据放在⼀个库⾥，不分轻重，同等对待。⼀旦因为⾮核⼼业务导致数据库宕机，核⼼业务也会受到牵连；



##### 场景-如何拆分

订单ID、⽤户ID、商户ID。

假设按⽤户ID维度拆分，同⼀个⽤户ID的所有订单会落到同⼀个库的同⼀张表⾥。当查询的时候，按⽤户 ID 查，可以很容易地定位到某个库的某个表；但如果按订单 ID 或商户 ID维度查询，就很难做。

- 建立映射表：

  1. 查询的时候根据商户ID查询映射表，得到⽤户**ID**；
  2. 再根据⽤户ID查询订单ID；

- 业务双写：两套分库分表，⼀套按⽤户ID切分，⼀套按商户ID 切分；

- 异步双写：业务单写，然后通过监听Binlog，同步到另外⼀套表上；

- 统一维度

  > ⽐如把⽤户ID作为订单ID中的某⼏位，这样订单ID中就包含了⽤户ID信息，然后按照⽤户ID 分库，当按订单ID查询的时候，截取出⽤户ID，再按⽤户 ID查询



##### join 问题

- Join拆成多个单表查询，在代码层对结果进⾏拼装；

- 做成宽表，空间换时间；

  > 宽表（Wide Table）是指具有大量列的表结构。
  >
  > 宽表的设计思想是将多个属性或字段合并到一个表中，以减少表之间的关联和连接操作。通过将相关属性直接存储在同一行的不同列中，宽表可以提供更快的数据访问和查询性能。
  >
  > 应用领域：
  >
  > - 日志分析；
  > - 电商商品表；

- 利用搜索引擎；



### 事务与锁



##### 单条语句的原子性

对于扣钱的事务，一般先把数据select后，再进行update，但是没有办法保证两条语句的原子性。可以改为一条语句：

```sql
UPDATE record SET count = count - 50 WHERE id = 1;
```

局限性：实际业务中，往往需要先获得表中的值，再进行更新。



##### 悲观锁

认为数据发⽣并发冲突的概率很⼤，所以读之前就上锁。

`SELECT ... FOR UPDATE` 的作用是获取选定行的共享锁（Shared Lock）或排他锁（Exclusive Lock），这取决于数据库的事务隔离级别：

- 共享锁允许其他事务同时读取选定行，但阻止其他事务对选定行进行修改；
- 排他锁则阻止其他事务对选定行进行读取或修改；

问题：

- 假如事务 A 在拿到锁之后、Commit 之前出问题了，会造成锁不能释放，数据库死锁；
- ⼀个事务拿到锁之后，其他访问该记录的事务都会被阻塞，这在⾼并发场景下会造成⽤户端的⼤量请求阻塞；



##### 乐观锁

认为数据发⽣并发冲突的概率⽐较⼩，所以读之前不上锁，等到写回去的时候再判断数据是否被其他事务改了。

以下是实现乐观锁的一般步骤：

1. 添加版本号或时间戳字段：在表中添加一个额外的字段，用于记录每次更新的版本号或时间戳。例如，可以使用整数类型的版本号字段或时间戳字段。
2. 查询数据：在事务开始时，先查询需要更新的数据，并获取当前的版本号或时间戳。
3. 执行业务逻辑：在事务中执行您的业务操作，对数据进行修改或计算。
4. 更新数据：在更新数据之前，检查之前获取的版本号或时间戳是否与当前数据库中的值一致。
   - 如果一致，说明没有其他并发事务修改过数据，可以继续执行更新操作，并将版本号或时间戳加一。
   - 如果不一致，说明其他并发事务已经修改了数据，可能存在冲突。您可以选**择终止当前事务**，或者根据具体业务需求进行处理，例如**重新读取数据并重试操作**。



```sql
START TRANSACTION;

SELECT xx, version FROM record WHERE condition;
-- 执行您的业务逻辑，并对数据进行修改
UPDATE record SET xx = new_value, version = version + 1 WHERE condition AND version = old_version;

COMMIT;
```



___



#### 间隙锁

间隙锁（Gap Lock）是一种锁定索引范围而不是特定行的机制。它用于在多个事务并发访问数据库时，保护索引范围内的间隙，防止其他事务插入或修改数据时破坏特定范围的完整性。

##### 分类

共享间隙锁（S-gap lock）和独占间隙锁（X-gap lock）。

- S-gap lock 允许其他事务获取相同间隙的 S-gap lock，但不允许其他事务获取 X-gap lock；
- X-gap lock 则是排它锁，其他事务无法获取相同间隙的任何类型的锁；



##### 工作过程

- 当一个事务获取间隙锁时，它会锁定索引范围内的间隙，包括但不限于两个索引值之间的空隙。这意味着其他事务无法在这个间隙内插入新的索引值；
- 在 InnoDB 中，间隙锁与行锁可以同时存在。当一个事务获取了一个间隙锁时，它也可以获取间隙内的行锁。这样可以确保事务在索引范围内的间隙和行都受到保护，防止其他事务插入或修改数据。

```sql
# 事务a
BEGIN;
SELECT * FROM products WHERE price BETWEEN 100 AND 200 FOR UPDATE;

# 事务b
BEGIN;
INSERT INTO products (id, name, price) VALUES (102, 'Product 102', 150);
COMMIT;
```

在事务 A 的 `SELECT` 语句中，使用了间隙锁来保护价格范围在 100 到 200 之间的产品。

事务 B 在插入一行新的产品（id 为 102）时，由于事务 A 持有了间隙锁，事务 B 会被阻塞，直到事务 A 释放间隙锁或回滚。



##### 应用场景

间隙锁的一个典型应用场景是防止**幻读**（Phantom Read）的发生。幻读指的是在同一个事务中，多次执行相同的查询，但结果集却发生了变化。通过使用间隙锁，MySQL 可以锁定索引范围，确保在同一个事务中执行相同查询时，其他事务无法在该范围内插入新的行，从而避免了幻读的问题。

需要注意的是，间隙锁只在某些隔离级别下才会生效，如 Repeatable Read (RR) 和 Serializable (SER) 隔离级别。







___



#### 死锁

- 死锁检测：通过判断资源图有无环判断是否死锁；

- 死锁解除：可以强制事务回滚；

- 死锁场景：
  - 事务A操作了表T1、T2的两条记录，事务B也操作了表T1、T2中同样的两条记录，顺序刚好反过来，可能发⽣死锁；
  - 





